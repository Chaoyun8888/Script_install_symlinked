#!/bin/bash

# -------------------------------------------------------------------
# box: a function to create a box of '=' characters around a given string
#
# usage: box 'testing'
box()
{
  local t="$1xxxx"
  local c=${2:-#}

  echo ${t//?/$c}
  echo "$c $1 $c"
  echo ${t//?/$c}
}

# -------------------------------------------------------------------
# htmlEntityToUTF8: convert html-entity to UTF-8
htmlEntityToUTF8()
{
  if [ $# -eq 0 ]; then
    echo "Usage: htmlEntityToUTF8 \"&#9661;\""
  else
    echo $1 | recode html..UTF8
  fi
}

# -------------------------------------------------------------------
# UTF8toHtmlEntity: convert UTF-8 to html-entity
UTF8toHtmlEntity()
{
  if [ $# -eq 0 ]; then
    echo "Usage: UTF8toHtmlEntity \"♥\""
  else
    echo $1 | recode UTF8..html
  fi
}

# -------------------------------------------------------------------
# optiImages: optimized images (png/jpg) in the current dir + sub-dirs
#
# INFO: use "grunt-contrib-imagemin" for websites!
optiImages()
{
  find . -iname '*.png' -exec optipng -o7 {} \;
  find . -iname '*.jpg' -exec jpegoptim --force {} \;
}

# -------------------------------------------------------------------
# lman: Open the manual page for the last command you executed.
lman()
{
  set -- $(fc -nl -1)
  while [ $# -gt 0 -a '(' "sudo" = "$1" -o "-" = "${1:0:1}" ')' ]; do
    shift
  done
  cmd="$(basename "$1")"
  man "$cmd" || help "$cmd"
}

# -------------------------------------------------------------------
# testConnection: check if connection to google.com is possible
#
# usage:
#   testConnection 1  # will echo 1 || 0
#   testConnection    # will return 1 || 0
testConnection()
{
  local tmpReturn=1
  $(wget --tries=2 --timeout=2 www.google.com -qO- &>/dev/null 2>&1)

  if [ $? -eq 0 ]; then
    tmpReturn=0
  else
    tmpReturn=1
  fi

  if [ "$1" ] && [ $1 -eq 1 ]; then
    echo $tmpReturn
  else
    return $tmpReturn
  fi
}

# -------------------------------------------------------------------
# netstat_used_local_ports: get used tcp-ports
netstat_used_local_ports()
{
  netstat -atn | awk '{printf "%s\n", $4}' | grep -oE '[0-9]*$' | sort -n | uniq
}

# -------------------------------------------------------------------
# netstat_free_local_port: get one free tcp-port
netstat_free_local_port()
{
  read lowerPort upperPort < /proc/sys/net/ipv4/ip_local_port_range

  # create a local array of used ports
  local all_used_ports=($(netstat_used_local_ports))

  for port in $(seq $lowerPort $upperPort); do
    for used_port in "${all_used_ports[@]}"; do
      if [ $used_port -eq $port ]; then
        continue
      else
        echo $port
        return 0
      fi
    done
  done
}

# -------------------------------------------------------------------
# connection_overview: get stats-overview about your connections
netstat_connection_overview()
{
  netstat -nat | awk '{print $6}' | sort | uniq -c | sort -n
}

# -------------------------------------------------------------------
# sniff: view HTTP traffic
#
# usage: sniff [eth0]
sniff()
{
  if [ $1 ]; then
    local device=$1
  else
    local device='eth0'
  fi

  sudo ngrep -d ${device} -t '^(GET|POST) ' 'tcp and port 80'
}

# -------------------------------------------------------------------
# httpdump: view HTTP traffic
#
# usage: httpdump [eth1]
httpdump()
{
  if [ $1 ]; then
    local device=$1
  else
    local device='eth0'
  fi

  sudo tcpdump -i ${device} -n -s 0 -w - | grep -a -o -E \"Host\: .*|GET \/.*\"
}

# -------------------------------------------------------------------
# iptablesBlockIP: block a IP via "iptables"
#
# usage: iptablesBlockIP 8.8.8.8
iptablesBlockIP()
{
  if [ "`id -u`" == "0" ] ; then
    iptables -A INPUT -s $1 -j DROP
  else
    sudo iptables -A INPUT -s $1 -j DROP
  fi
}

# -------------------------------------------------------------------
# ips: get the local IP's
ips()
{
  local _ip _myip _line _nl=$'\n'

  while IFS=$': \t' read -a _line ; do
    [ -z "${_line%inet}" ] &&
      _ip=${_line[${#_line[1]}>4?1:2]} &&
        [ "${_ip#127.0.0.1}" ] &&
          _myip=$_ip
    done< <(LANG=C ifconfig)

  printf ${1+-v} $1 "%s${_nl:0:$[${#1}>0?0:1]}" $_myip
}

# -------------------------------------------------------------------
# cleanTheSystem: purge old config, kernel, trash etc.
#
# WARNING: take a look on what the package-manager will do
cleanTheSystem()
{
  local OLDCONF=$(dpkg -l | grep "^rc"|awk '{print $2}')
  local CURKERNEL=$(uname -r | sed 's/-*[a-z]//g' | sed 's/-386//g' | sed 's/-164//g')
  local LINUXPKG="linux-(image|headers|ubuntu-modules|restricted-modules)"
  local METALINUXPKG="linux-(image|headers|restricted-modules)-(generic|i386|amd64|server|common|rt|xen)"
  local OLDKERNELS=$(dpkg -l | awk '{print $2}' | grep -E $LINUXPKG | grep -vE $METALINUXPKG | grep -v $CURKERNEL)

  echo -e $COLOR_YELLOW"clear ".deb"-cache ..."$COLOR_NO_COLOR
  sudo aptitude autoclean

  echo -e $COLOR_RED"remove not needed packages ..."$COLOR_NO_COLOR
  sudo apt-get autoremove

  echo -e $COLOR_YELLOW"remove old config-files..."$COLOR_NO_COLOUR
  sudo aptitude purge $OLDCONF

  echo -e $COLOR_YELLOW"remove old kernels ..."$COLOR_NO_COLOUR
  sudo aptitude purge $OLDKERNELS

  echo -e $COLOR_YELLOW"clean trash ..."$COLOR_NO_COLOUR
  sudo rm -rf /home/*/.local/share/Trash/*/** &> /dev/null
  sudo rm -rf /root/.local/share/Trash/*/** &> /dev/null

  echo -e $COLOR_YELLOW"... everything is clean!!!"$COLOR_NO_COLOUR
}

# -------------------------------------------------------------------
# extract: extract of compressed-files
extract()
{
  if [ -f $1 ] ; then
    case $1 in
      *.tar.bz2)   tar xvjf $1     ;;
      *.tar.gz)    tar xvzf $1     ;;
      *.bz2)       bunzip2 $1      ;;
      *.rar)       unrar x $1      ;;
      *.gz)        gunzip $1       ;;
      *.tar)       tar xvf $1      ;;
      *.tbz2)      tar xvjf $1     ;;
      *.tgz)       tar xvzf $1     ;;
      *.zip)       unzip $1        ;;
      *.Z)         uncompress $1   ;;
      *.7z)        7z x $1         ;;
      *)           echo "'$1' cannot be extracted via >extract<" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

# -------------------------------------------------------------------
# os-info: show some info about your system
os-info()
{
  lsb_release -a
  uname -a

  if [ -z /etc/lsb-release ]; then
    cat /etc/lsb-release;
  fi;

  if [ -z /etc/issue ]; then
    cat /etc/issue;
  fi;

  if [ -z /proc/version ]; then
    cat /proc/version;
  fi;
}

# -------------------------------------------------------------------
# stripspace: strip unnecessary whitespace from file
stripspace()
{
  if [ $# -eq 0 ]; then
    echo "Usage: stripspace FILE"
  else
    local tempfile=mktemp
    git stripspace < "$1" > tempfile
    mv tempfile "$1"
  fi
}

# -------------------------------------------------------------------
# battery_life : Echo the percentage of battery life remaining
battery_life ()
{
  local life=$(acpi -b | cut -d "," -f 2)
  # NOTE: the trailing % is stripped
  echo ${life%\%}
}

# -------------------------------------------------------------------
# battery_indicator: echo a indicator for your battery-time
battery_indicator()
{
  local num=$(battery_life)

  if [ $num -gt 95 ]; then
    # 95-100% remaining : GREEN
    echo -e "${COLOR_GREEN}♥♥♥♥♥♥${COLOR_NO_COLOUR}"
  elif [ $num -gt 85 ]; then
    # 85-95% remaining : GREEN
    echo -e "${COLOR_GREEN}♥♥♥♥♥♡${COLOR_NO_COLOUR}"
  elif [ $num -gt 65 ]; then
    # 65-85% remaining : GREEN
    echo -e "${COLOR_GREEN}♥♥♥♥♡♡${COLOR_NO_COLOUR}"
  elif [ $num -gt 45 ]; then
    # 45-65% remaining : GREEN
    echo -e "${COLOR_GREEN}♥♥♥♡♡♡${COLOR_NO_COLOUR}"
  elif [ $num -gt 25 ]; then
    # 25-45% remaining : GREEN
    echo -e "${COLOR_GREEN}♥♥♡♡♡♡${COLOR_NO_COLOUR}"
  elif [ $num -gt 10 ]; then
    # 11-25% remaining : YELLOW
    echo -e "${COLOR_YELLOW}♥♡♡♡♡♡${COLOR_NO_COLOUR}"
  else
    # 0-10% remaining : RED
    echo -e "${COLOR_RED}♥♡♡♡♡♡${COLOR_NO_COLOUR}"
  fi
}

# -------------------------------------------------------------------
# logssh: establish ssh connection + write a logfile
logssh()
{
  ssh $1 | tee sshlog
}

# -------------------------------------------------------------------
# WARNING -> replace: changes multiple files at once
replace()
{
  if [ $3 ]; then
    find $1 -type f -exec sed -i 's/$2/$3/g' {} \;
  else
    echo "Missing argument"
  fi
}

# -------------------------------------------------------------------
# calc: Simple calculator
calc()
{
  local result=""
  result="$(printf "scale=10;$*\n" | bc --mathlib | tr -d '\\\n')"
  #                       └─ default (when `--mathlib` is used) is 20
  #
  if [[ "$result" == *.* ]]; then
    # improve the output for decimal numbers
    printf "$result" |
    sed -e 's/^\./0./'        `# add "0" for cases like ".5"` \
        -e 's/^-\./-0./'      `# add "0" for cases like "-.5"`\
        -e 's/0*$//;s/\.$//'   # remove trailing zeros
  else
    printf "$result"
  fi
  printf "\n"
}

# -------------------------------------------------------------------
# mkd: Create a new directory and enter it
mkd()
{
  mkdir -p "$@" && cd "$@"
}

# -------------------------------------------------------------------
# passwdgen: a password generator
#
# usage: passwdgen 8
passwdgen()
{
  if [ $1 ]; then
    local length=$1
  else
    local length=16
  fi

  cat /dev/urandom | head -c${1:-512} | sha512sum | head -c${1:-${length}}
}

# -------------------------------------------------------------------
# targz: Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
targz()
{
  local tmpFile="${@%/}.tar"
  local size=0
  local cmd=""

  tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1

  size=$(
    stat -f"%z" "${tmpFile}" 2> /dev/null; # OS X `stat`
    stat -c"%s" "${tmpFile}" 2> /dev/null # GNU `stat`
  )

  if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
    # the .tar file is smaller than 50 MB and Zopfli is available; use it
    cmd="zopfli"
  else
    if hash pigz 2> /dev/null; then
      cmd="pigz"
    else
      cmd="gzip"
    fi
  fi

  echo "Compressing .tar using \`${cmd}\`…"
  "${cmd}" -v "${tmpFile}" || return 1
  [ -f "${tmpFile}" ] && rm "${tmpFile}"
  echo "${tmpFile}.gz created successfully."
}

# -------------------------------------------------------------------
# fs: Determine size of a file or total size of a directory
fs()
{
  if du -b /dev/null > /dev/null 2>&1; then
    local arg=-sbh
  else
    local arg=-sh
  fi

  if [[ -n "$@" ]]; then
    du $arg -- "$@"
  else
    du $arg .[^.]* *
  fi
}

# -------------------------------------------------------------------
# ff: displays all files in the current directory (recursively)
ff()
{
  find . -type f -iname '*'$*'*' -ls
}

# -------------------------------------------------------------------
# fstr: find text in files
fstr()
{
  OPTIND=1
  local case=""
  local usage="fstr: find string in files.
  Usage: fstr [-i] \"pattern\" [\"filename pattern\"] "

  while getopts :it opt
  do
        case "$opt" in
        i) case="-i " ;;
        *) echo "$usage"; return;;
        esac
  done

  shift $(( $OPTIND - 1 ))
  if [ "$#" -lt 1 ]; then
    echo "$usage"
    return
  fi

  find . -type f -name "${2:-*}" -print0 | \
  xargs -0 egrep --color=auto -sn ${case} "$1" 2>&- | more
}

# -------------------------------------------------------------------
# file_backup_compressed: create a compressed backup (with date)
#
# usage: file_backup_simple test.txt
file_backup_compressed()
{
  tar czvf "${1}-$(date +%y%m%d-%H%M%S).tar.gz" "$1"
}

# -------------------------------------------------------------------
# file_backup: creating a backup of a file (with date)
file_backup()
{
  for FILE ; do
    [[ -e "$1" ]] && cp "$1" "${1}_$(date +%Y-%m-%d_%H-%M-%S)" || echo "\"$1\" not found." >&2
  done
}

# -------------------------------------------------------------------
# file_information: output information to a file
file_information()
{
  if [ $1 ]; then
    if [ -z $1 ]; then
      echo "$1: not found"
      return
    fi

    echo $1
    ls -l $1
    file $1
    ldd $1
  else
    echo "Missing argument"
  fi
}

# -------------------------------------------------------------------
# dataurl: create a data URL from a file
dataurl()
{
  local mimeType=$(file -b --mime-type "$1")

  if [[ $mimeType == text/* ]]; then
    mimeType="${mimeType};charset=utf-8"
  fi

  echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')"
}

# -------------------------------------------------------------------
# gitio: create a git.io short URL
gitio()
{
  if [ -z "${1}" -o -z "${2}" ]; then
    echo "Usage: \`gitio slug url\`"
    return 1
  fi

  curl -i http://git.io/ -F "url=${2}" -F "code=${1}"
}

# -------------------------------------------------------------------
# shorturl: Create a short URL
shorturl() 
{
  if [ -z "${1}" ]; then
    echo "Usage: \`shorturl url\`"
    return 1
  fi

  curl -s https://www.googleapis.com/urlshortener/v1/url \
    -H 'Content-Type: application/json' \
    -d '{"longUrl": '\"$1\"'}' | grep id | cut -d '"' -f 4
}

# -------------------------------------------------------------------
# server: Start an HTTP server from a directory, optionally specifying the port
server()
{
  local free_port=$(netstat_free_local_port)
  local port="${1:-${free_port}}"
  sleep 1 && xdg-open "http://localhost:${port}/" &
  # Set the default Content-Type to `text/plain` instead of `application/octet-stream`
  # And serve everything as UTF-8 (although not technically correct, this doesn’t break anything for binary files)
  python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port"
}

# -------------------------------------------------------------------
# phpserver: Start a PHP server from a directory, optionally specifying the port
# (Requires PHP 5.4.0+.)
#
# usage:
# phpserver [port=4000] [ip=127.0.0.1]
phpserver()
{
  local free_port=$(netstat_free_local_port)
  local port="${1:-${free_port}}"
  local ip="${2:-127.0.0.1}"
  sleep 1 && xdg-open "http://${ip}:${port}/" &
  php -S "${ip}:${port}"
}

# php-parse-error-check: check for parse errors
#
# usage: php-parse-error-check /var/www/web3/
php-parse-error-check()
{
  if [ $1 ]; then
    local location=$1
  else
    local location="."
  fi

  find ${location} -name "*.php" -exec php -l {} \; | grep "Parse error"
}

# -------------------------------------------------------------------
# psgrep: grep a process
psgrep()
{
  if [ ! -z $1 ] ; then
    echo "Grepping for processes matching $1..."
    ps aux | grep $1 | grep -v grep
  else
    echo "!! Need a process-name to grep for"
  fi
}

# -------------------------------------------------------------------
# gz: Compare original and gzipped file size
gz()
{
  local origsize=$(wc -c < "$1")
  local gzipsize=$(gzip -c "$1" | wc -c)
  local ratio=$(echo "$gzipsize * 100/ $origsize" | bc -l)
  printf "orig: %d bytes\n" "$origsize"
  printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio"
}

# -------------------------------------------------------------------
# json: Syntax-highlight JSON strings or files
#
# usage: json '{"foo":42}'` or `echo '{"foo":42}' | json
json()
{
  if [ -t 0 ]; then # argument
    python -mjson.tool <<< "$*" | pygmentize -l javascript
  else # pipe
    python -mjson.tool | pygmentize -l javascript
  fi
}

# -------------------------------------------------------------------
# digga: All the dig info
digga()
{
  dig +nocmd "$1" any +multiline +noall +answer
}

# -------------------------------------------------------------------
# escape: Escape UTF-8 characters into their 3-byte format
escape()
{
  printf "\\\x%s" $(printf "$@" | xxd -p -c1 -u)
  # print a newline unless we’re piping the output to another program
  if [ -t 1 ]; then
    echo # newline
  fi
}

# -------------------------------------------------------------------
# unidecode: Decode \x{ABCD}-style Unicode escape sequences
unidecode()
{
  perl -e "binmode(STDOUT, ':utf8'); print \"$@\""
  # print a newline unless we’re piping the output to another program
  if [ -t 1 ]; then
    echo # newline
  fi
}

# -------------------------------------------------------------------
# codepoint: Get a character’s Unicode code point
codepoint()
{
  perl -e "use utf8; print sprintf('U+%04X', ord(\"$@\"))"
  # print a newline unless we’re piping the output to another program
  if [ -t 1 ]; then
    echo # newline
  fi
}

# -------------------------------------------------------------------
# getcertnames: Show all the names (CNs and SANs) listed in the SSL certificate
# for a given domain
getcertnames()
{
  if [ -z "${1}" ]; then
    echo "ERROR: No domain specified."
    return 1
  fi

  local domain="${1}"
  echo "Testing ${domain}…"
  echo # newline

  local tmp=$(echo -e "GET / HTTP/1.0\nEOT" \
    | openssl s_client -connect "${domain}:443" 2>&1);

  if [[ "${tmp}" = *"-----BEGIN CERTIFICATE-----"* ]]; then
    local certText=$(echo "${tmp}" \
      | openssl x509 -text -certopt "no_header, no_serial, no_version, \
      no_signame, no_validity, no_issuer, no_pubkey, no_sigdump, no_aux");
      echo "Common Name:"
      echo # newline
      echo "${certText}" | grep "Subject:" | sed -e "s/^.*CN=//";
      echo # newline
      echo "Subject Alternative Name(s):"
      echo # newline
      echo "${certText}" | grep -A 1 "Subject Alternative Name:" \
        | sed -e "2s/DNS://g" -e "s/ //g" | tr "," "\n" | tail -n +2
      return 0
  else
    echo "ERROR: Certificate not found.";
    return 1
  fi
}

# -------------------------------------------------------------------
# note: add a note to the ~/notes.txt file
#
# usage:  note 'title' 'body'
#         echo 'body' | note
note()
{
  local title
  local body

  if [ -t 0 ]; then
    title="$1"
    body="$2"
  else
    title=$(cat)
  fi

  echo "Title: ${title} Body: ${body}" >> ~/notes.txt
}

# -------------------------------------------------------------------
# tail with search highlight
#
# usage: t /var/log/Xorg.0.log kHz
t()
{
tail -f $1 | perl -pe "s/$2/${COLOR_LIGHT_RED}$&${COLOR_NO_COLOUR}/g"
}


# -------------------------------------------------------------------
# httpDebug: download a web page and show info on what took time
#
# usage: httpDebug http://github.com
httpDebug()
{
  curl $@ -o /dev/null -w "dns: %{time_namelookup} connect: %{time_connect} pretransfer: %{time_pretransfer} starttransfer: %{time_starttransfer} total: %{time_total}\n"
}


# -------------------------------------------------------------------
# gi: Install Grunt plugins and add them as `devDependencies` to `package.json`
#
# usage: gid contrib-watch contrib-uglify
gid()
{
  npm install --save-dev ${*/#/grunt-}
}

# -------------------------------------------------------------------
# Install Grunt plugins and add them as `dependencies` to `package.json`
#
# usage: gi contrib-watch contrib-uglify
gi()
{
  npm install --save ${*/#/grunt-}
}

# -------------------------------------------------------------------
# `m`: with no arguments opens the current directory in TextMate, otherwise
# opens the given location
m()
{
  if [ $# -eq 0 ]; then
    mate .
  else
    mate "$@"
  fi
}

# -------------------------------------------------------------------
# `s`: with no arguments opens the current directory in Sublime Text, otherwise
# opens the given location
s()
{
  if [ $# -eq 0 ]; then
    subl -a .
  else
    subl -a "$@"
  fi
}

# -------------------------------------------------------------------
# `a`: with no arguments opens the current directory in Atom Editor, otherwise
# opens the given location
a()
{
  if [ $# -eq 0 ]; then
    atom .
  else
    atom "$@"
  fi
}

# -------------------------------------------------------------------
# `v`: with no arguments opens the current directory in Vim, otherwise opens the
# given location
v()
{
  if [ $# -eq 0 ]; then
    vim .
  else
    vim "$@"
  fi
}

# -------------------------------------------------------------------
# `o`: with no arguments opens current directory, otherwise opens the given
# location
o()
{
  if [ $# -eq 0 ]; then
    xdg-open .
  else
    xdg-open "$@"
  fi
}

# -------------------------------------------------------------------
# `tre`: is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
tre()
{
  tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX
}

